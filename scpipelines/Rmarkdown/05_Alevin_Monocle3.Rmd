---
title: "Monocle3"
output: html_document
---

This Rmarkdown was adapted from the vignette provided by monocle3: https://cole-trapnell-lab.github.io/monocle3/docs/


```{r}
knitr::opts_chunk$set(cache=FALSE, warning = FALSE, message = FALSE)
library(monocle3)
library(tximport)
library(org.Hs.eg.db)
library("AnnotationDbi")
library(garnett)
library(biomaRt)
library(EnsDb.Hsapiens.v75)
```

# Import the data

The first step is to import the data from salmon and then import the metrics from the QC cleaning steps. The second step is to filter the data to leave only the "good" cells.

```{r}

txi.control <- tximport("salmon.dir/pbmc_1k_v3_S1/alevin/quants_mat.gz", type="alevin")
d <- as.matrix(txi.control$counts)

# Import the filtering QC metrics clean object and filter the names from that object
metrics_clean <- readRDS( "metrics_clean.rds")
d <- d[,metrics_clean$cells]

SYMBOL <- mapIds(EnsDb.Hsapiens.v75,keys=rownames(d),column="SYMBOL",keytype="GENEID",multiVals="first")

symbol <- as.data.frame(SYMBOL)
symbol$ENSEMBL <- rownames(symbol)
```

# Set up the monocle3 object

The first step in working with Monocle 3 is to load up your data into Monocle 3's main class, cell_data_set:

```{r}
# A column called gene_short_name is required for monocle3
colnames(symbol) <- c("gene_short_name", "ensembl")  

control <- new_cell_data_set(d,
                             cell_metadata = metrics_clean,
                             gene_metadata = symbol)
```


# Preprocess the data

Now that the data's all loaded up, we need to pre-process it. This step is where you tell Monocle 3 how you want to normalize the data, whether to use Principal Components Analysis (the standard for RNA-seq) or Latent Semantic Indexing (common in ATAC-seq), and how to remove any batch effects. We will just use the standard PCA method in this demonstration. When using PCA, you should specify the number of principal components you want Monocle to compute.

```{r}
control <- preprocess_cds(control, num_dim = 20)
```

# Plot PCs

It's a good idea to check that you're using enough PCs to capture most of the variation in gene expression across all the cells in the data set. You can look at the fraction of variation explained by each PC using plot_pc_variance_explained():

```{r}
plot_pc_variance_explained(control)
```

# Remove batch effects

This is an optional function that we wont use today as there are no batch effects within the data. You can subtracted unwatched batch effects or align cells from similar (but not exactly) the same conditions using several different methods in Monocle 3.

```{r}
cds <- align_cds(cds, alignment_group = "batch")
```


# Reduce dimensions and cluster

```{r}
control <- reduce_dimension(control)

# If you would like to use tSNE then:
# control <- reduce_dimension(control, reduction_method="tSNE")
# Then when you plot cells use: plot_cells(control, reduction_method="tSNE")

control <- cluster_cells(control, resolution=1e-5)
```


# Plot clusters

```{r}
plot_cells(control, color_cells_by="cluster", label_branch_points = FALSE, label_roots = FALSE, label_leaves = FALSE, show_trajectory_graph = FALSE)
```

# Plot meta features 

In addition to plotting clusters you are able to plot meta features

```{r}
plot_cells(control, color_cells_by="mitoRatio", label_branch_points = FALSE, label_roots = FALSE, label_leaves = FALSE, show_trajectory_graph = FALSE)
```

# plot genes on UMAP plot

```{r}
plot_cells(control, genes=c("CD3D"), cell_size = 0.7, 
label_branch_points = FALSE, label_roots = FALSE, label_leaves = FALSE, show_trajectory_graph = FALSE)
```

# Find marker genes expressed by each cluster

Just like in Seurat, monocle 3 also has the functionality to allow the identification of markers that define each cluster.

The data frame marker_test_res contains a number of metrics for how specifically expressed each gene is in each partition. We could group the cells according to cluster, partition, or any categorical variable in colData(cds). You can rank the table according to one or more of the specificity metrics and take the top gene for each cluster. For example, pseudo_R2 is one such measure.

```{r}
marker_test_res <- top_markers(control, group_cells_by="cluster", 
                               reference_cells=1000, cores=8)

top_specific_markers <- marker_test_res %>%
                            dplyr::filter(fraction_expressing >= 0.10) %>%
                            group_by(cell_group) %>%
                            top_n(1, pseudo_R2)

top_specific_marker_ids <- unique(top_specific_markers %>% pull(gene_id))
```


# Plot the genes by group

Now, we can plot the expression and fraction of cells that express each marker in each group with the plot_genes_by_group function:

```{r}
plot_genes_by_group(control,
                    top_specific_marker_ids,
                    group_cells_by="cluster",
                    ordering_type="maximal_on_diag",
                    max.size=3)
```

It's often informative to look at more than one marker, which you can do just by changing the first argument to top_n():

```{r}
top_specific_markers <- marker_test_res %>%
                            dplyr::filter(fraction_expressing >= 0.10) %>%
                            group_by(cell_group) %>%
                            top_n(3, pseudo_R2)

top_specific_marker_ids <- unique(top_specific_markers %>% pull(gene_id))

plot_genes_by_group(control,
                    top_specific_marker_ids,
                    group_cells_by="partition",
                    ordering_type="cluster_row_col",
                    max.size=3)
```


# Order cells in pseudotime along a trajectory

Now, put your cells in order by how much progress they've made through whatever process you're studying, such as differentiation, reprogramming, or an immune response.

For the purposes of this example we are going to order our cells using the GO term for immune cell activation.

```{r}
control <- learn_graph(control)

control <- order_cells(control, root_cells = control$cell[[1]])
plot_cells(control)

```

# Perform differential expression analysis

Compare groups of cells in myriad ways to find differentially expressed genes, controlling for batch effects and treatments as you like:

```{r}
# With regression:
gene_fits <- fit_models(cds, model_formula_str = "~embryo.time")
fit_coefs <- coefficient_table(gene_fits)
emb_time_terms <- fit_coefs %>% filter(term == "embryo.time")
emb_time_terms <- emb_time_terms %>% mutate(q_value = p.adjust(p_value))
sig_genes <- emb_time_terms %>% filter (q_value < 0.05) %>% pull(gene_short_name)

# With graph autocorrelation:
pr_test_res <- graph_test(cds,  neighbor_graph="principal_graph", cores=4)
pr_deg_ids <- row.names(subset(pr_test_res, q_value < 0.05))
```