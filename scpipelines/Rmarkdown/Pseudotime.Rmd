---
title: "Pseudotime"
output: html_document
---

```{r setup, include=FALSE}
library(SummarizedExperiment)
library(monocle)
library(M3Drop)
library(scater)
library(ggplot2)
library(ggbeeswarm)
library(ggthemes)
library(tidyverse)
library(org.Hs.eg.db)
library(AnnotationDbi)
sce.pass <- readRDS("../SCE.dir/pass_clustering.rds")
```


# Pseudotime based on PCA

## PCA

```{r, echo=FALSE, message=FALSE, warning=FALSE}
## if your data has labels then modify function below and add them
sc3 <- colnames(colData(sce.pass)[,grep("sc3_", colnames(colData(sce.pass)))])

#sce.pass$Condition <- factor(
#    sce.pass$
#      Condition,
#    levels = c("Hypo", "Norm")
#)
extract <- sc3[1]
cellLabels <- sce.pass[[extract]]
sce <- counts(sce.pass)
colnames(sce) <- cellLabels
sce.pass <- normalize(sce.pass)
svg("PCA.svg")  
scater::plotPCA(sce.pass)
dev.off()

scater::plotPCA(sce.pass, colour_by = sc3[1])
```



## PCA ordered navie ordered pseudotime

```{r,echo=FALSE, message=FALSE, warning=FALSE}
sce.pass <- runPCA(sce.pass)
sce.pass$PC1 <- reducedDim(sce.pass, "PCA")[,1]

postscript("Pseudotime_PCA.eps")  
ggplot(as.data.frame(colData(sce.pass)), aes(x = PC1, y = sc3[1], 
                              colour = sc3[1])) +
    geom_quasirandom(groupOnX = FALSE) +
    scale_color_tableau() + theme_classic() +
    xlab("First principal component") + ylab("Timepoint") +
    ggtitle("Cells ordered by first principal component")
dev.off()

ggplot(as.data.frame(colData(sce.pass)), aes(x = PC1, y = as.character(sc3[1]), 
                              colour = as.character(sc3[1]))) +
    geom_quasirandom(groupOnX = FALSE) +
    scale_color_tableau() + theme_classic() +
    xlab("First principal component") + ylab("Timepoint") +
    ggtitle("Cells ordered by first principal component")
```



Naive pseudotime orders the cells perfects on PC1. Now can bespoke pseudotime offer any advantages.

# Monocle 

Monocle skips the clustering stage of TSCAN and directly builds a minimum spanning tree on a reduced dimension representation of the cells to connect all cells. Monocle then identifies the longest path in this tree to determine pseudotime. If the data contains diverging trajectories (i.e. one cell type differentiates into two different cell-types), monocle can identify these. Each of the resulting forked paths is defined as a separate cell state.

First the data needs to be parsed so only features relevant are selected using M3Drop.

```{r, include=FALSE, warning=FALSE}

Normalized_data <- M3DropCleanData(assay(sce.pass),
                      labels = rownames(sce.pass),
                      is.counts=TRUE, min_detected_genes=20)
DE_genes <- M3DropDifferentialExpression(Normalized_data$data,
  mt_method="fdr", mt_threshold=0.01)


# The only select genes that are a factor of hypoxia response
GO <- read.csv("GO_term_hypoxia.csv")
GO <- GO %>% 
  filter(Annotated.Term == "response to hypoxia")
GO$Symbol = toupper(GO$Symbol)


d <- sce.pass[which(rownames(sce.pass) %in% unique(GO$Symbol)), ]
d <- d[!duplicated(rownames(d)), ]
```

# Plot the monocle cell trajectory {.tabset}

## by state

```{r, echo=FALSE, message=FALSE, warning=FALSE}
colnames(d) <- 1:ncol(d)
geneNames <- rownames(d)
rownames(d) <- 1:nrow(d)
pd <- data.frame(timepoint = cellLabels)
pd <- new("AnnotatedDataFrame", data=pd)
fd <- data.frame(gene_short_name = geneNames)
fd <- new("AnnotatedDataFrame", data=fd)

dCellData <- newCellDataSet(assay(d), phenoData = pd, featureData = fd, expressionFamily = tobit())
dCellData <- setOrderingFilter(dCellData, which(geneNames %in% DE_genes))
dCellData <- estimateSizeFactors(dCellData)
dCellDataSet <- reduceDimension(dCellData, pseudo_expr = 1)
dCellDataSet <- orderCells(dCellDataSet, reverse = FALSE)
postscript("Figures.dir/Pseudotime_states_MCF7.eps")  
plot_cell_trajectory(dCellDataSet)
dev.off()
```

## by condition

```{r}
postscript("Figures.dir/Pseudotime_condition_MCF7.eps")  
plot_cell_trajectory(dCellDataSet, color_by = "timepoint")
dev.off()
```

## by pseudotime

```{r}
postscript("Figures.dir/Pseudotime_psuedotime_MCF7.eps")
plot_cell_trajectory(dCellDataSet, color_by = "Pseudotime")
dev.off()
```

```{r}
postscript("Figures.dir/Pseudotime_condition_split_MCF7.eps")
plot_cell_trajectory(dCellDataSet, color_by = "timepoint") +
    facet_wrap(~timepoint, nrow = 1)
dev.off()
```

#Differential expression accross pseudotime

```{r,message=FALSE, warning=FALSE}

Normalized_data <- M3DropCleanData(assay(sce),
                      labels = rownames(sce),
                      is.counts=TRUE, min_detected_genes=20)
DE_genes <- M3DropDifferentialExpression(Normalized_data$data,
  mt_method="fdr", mt_threshold=0.01)

d <- sce[which(rownames(sce) %in% DE_genes$Gene), ]
d <- d[!duplicated(rownames(d)), ]
colnames(d) <- 1:ncol(d)
geneNames <- rownames(d)
rownames(d) <- 1:nrow(d)
pd <- data.frame(timepoint = cellLabels)
pd <- new("AnnotatedDataFrame", data=pd)
fd <- data.frame(gene_short_name = geneNames)
fd <- new("AnnotatedDataFrame", data=fd)

dCellData <- newCellDataSet(d, phenoData = pd, featureData = fd, expressionFamily = tobit())
dCellData <- setOrderingFilter(dCellData, which(geneNames %in% DE_genes))
dCellData <- estimateSizeFactors(dCellData)
dCellDataSet <- reduceDimension(dCellData, pseudo_expr = 1)
dCellDataSet <- orderCells(dCellDataSet, reverse = FALSE)

diff_test_res <- differentialGeneTest(dCellDataSet,
                                      fullModelFormulaStr = "~sm.ns(Pseudotime)")

ensembl_to_symbol <- function(dataframe, ensembl_column){
  
  dataframe_tmp <- dataframe %>% 
    dplyr::select(ensembl_column)
  data <- unlist(dataframe_tmp)
  data <- as.vector(data)
  annots <-  AnnotationDbi::select(org.Hs.eg.db, keys=data,
                                   columns=c("SYMBOL","GENENAME"), keytype = "ENSEMBL")

  result <- merge(dataframe, annots, by.x=ensembl_column, by.y="ENSEMBL")
  return(result)
  }

diff_test_res <- ensembl_to_symbol(diff_test_res, "gene_short_name")

write.csv(diff_test_res, "pseaudotime_diff_exprs.csv")
```


```{r, include=FALSE}
pseudotime_monocle <-
    data.frame(
        Timepoint = phenoData(dCellDataSet)$timepoint,
        pseudotime = phenoData(dCellDataSet)$Pseudotime,
        State = phenoData(dCellDataSet)$State
    )
rownames(pseudotime_monocle) <- 1:ncol(d)
pseudotime_order_monocle <-
    rownames(pseudotime_monocle[order(pseudotime_monocle$pseudotime), ])
```


# Plot the cells ordered by pseudotime

```{r, echo=FALSE, message=FALSE, warning=FALSE}
sce.pass$pseudotime_monocle <- pseudotime_monocle$pseudotime

postscript("Figures.dir/Pseudotime_monocle_MCF7.eps")
ggplot(as.data.frame(colData(sce.pass)), 
       aes(x = pseudotime_monocle, 
           y = Condition, colour = Condition)) +
    geom_quasirandom(groupOnX = FALSE) +
    scale_color_tableau() + theme_classic() +
    xlab("monocle pseudotime") + ylab("Timepoint") +
    ggtitle("Cells ordered by monocle pseudotime")
dev.off()
```


## PCA HCC

```{r, echo=FALSE, message=FALSE, warning=FALSE}
sce.pass_hcc$Condition <- factor(
    sce.pass_hcc$Condition,
    levels = c("Hypoxia", "Normoxia")
)
cellLabels <- sce.pass_hcc$Condition
sce <- counts(sce.pass_hcc)
colnames(sce) <- cellLabels
svg("Figures.dir/PCA_HCC.svg")  
plotPCA(sce.pass_hcc, colour_by = "Condition")
dev.off()
```


## PCA ordered navie ordered pseudotime HCC

```{r,echo=FALSE, message=FALSE, warning=FALSE}
sce.pass_hcc$PC1 <- reducedDim(sce.pass_hcc)[,1]

postscript("Figures.dir/Pseudotime_PCA_HCC.eps") 
ggplot(as.data.frame(colData(sce.pass_hcc)), aes(x = PC1, y = Condition, 
                              colour = Condition)) +
    geom_quasirandom(groupOnX = FALSE) +
    scale_color_tableau() + theme_classic() +
    xlab("First principal component") + ylab("Timepoint") +
    ggtitle("Cells ordered by first principal component")
dev.off()
```

# DE accross pseudotime

```{r}
#postscript("Figures.dir/Pseudotime_heatmap.eps")
tiff("Figures.dir/Pseudotime_heatmap_MCF7.tiff")
plot_pseudotime_heatmap(dCellDataSet,
                num_clusters = 5,
                cores = 2,
                show_rownames = F)
dev.off()
```

# Monocle HCC




Monocle skips the clustering stage of TSCAN and directly builds a minimum spanning tree on a reduced dimension representation of the cells to connect all cells. Monocle then identifies the longest path in this tree to determine pseudotime. If the data contains diverging trajectories (i.e. one cell type differentiates into two different cell-types), monocle can identify these. Each of the resulting forked paths is defined as a separate cell state.

First the data needs to be parsed so only features relevant are selected using M3Drop.

```{r, include=FALSE, warning=FALSE}
Normalized_data <- M3DropCleanData(sce,
                      labels = rownames(sce),
                      is.counts=TRUE, min_detected_genes=2000)
DE_genes <- M3DropDifferentialExpression(Normalized_data$data,
  mt_method="fdr", mt_threshold=0.01)


# The only select genes that are a factor of hypoxia response
GO <- read.csv("GO_term_hypoxia.csv")
GO <- GO %>% 
  filter(Annotated.Term == "response to hypoxia")
GO$Symbol = toupper(GO$Symbol)

symbol_to_ensembl <- function(dataframe, ensembl_column){
  
  dataframe_tmp <- dataframe %>% 
    dplyr::select(ensembl_column)
  data <- unlist(dataframe_tmp)
  data <- as.vector(data)
  annots <-  AnnotationDbi::select(org.Hs.eg.db, keys=data,
                                   columns="ENSEMBL", keytype ="SYMBOL")

  result <- merge(dataframe, annots, by.x=ensembl_column, by.y="SYMBOL")
  return(result)
  }

GO <- symbol_to_ensembl(GO, "Symbol")

d <- sce[which(rownames(sce) %in% unique(GO$ENSEMBL)), ]
d <- d[!duplicated(rownames(d)), ]
```

# Plot the monocle cell trajectory {.tabset}

## by state

```{r, echo=FALSE, message=FALSE, warning=FALSE}
colnames(d) <- 1:ncol(d)
geneNames <- rownames(d)
rownames(d) <- 1:nrow(d)
pd <- data.frame(timepoint = cellLabels)
pd <- new("AnnotatedDataFrame", data=pd)
fd <- data.frame(gene_short_name = geneNames)
fd <- new("AnnotatedDataFrame", data=fd)

dCellData <- newCellDataSet(d, phenoData = pd, featureData = fd, expressionFamily = tobit())
dCellData <- setOrderingFilter(dCellData, which(geneNames %in% DE_genes))
dCellData <- estimateSizeFactors(dCellData)
dCellDataSet <- reduceDimension(dCellData, pseudo_expr = 1)
dCellDataSet <- orderCells(dCellDataSet, reverse = FALSE)
postscript("Figures.dir/Pseudotime_states_HCC.eps") 
plot_cell_trajectory(dCellDataSet)
dev.off()
```

## by condition

```{r}
postscript("Figures.dir/Pseudotime_condition_HCC.eps")  
plot_cell_trajectory(dCellDataSet, color_by = "timepoint")
dev.off()
```

## by pseudotime

```{r}
postscript("Figures.dir/Pseudotime_pseudotime_HCC.eps")  
plot_cell_trajectory(dCellDataSet, color_by = "Pseudotime")
dev.off(0)
```

```{r}
postscript("Figures.dir/Pseudotime_condition_split_HCC.eps")
plot_cell_trajectory(dCellDataSet, color_by = "timepoint") +
    facet_wrap(~timepoint, nrow = 1)
dev.off()
```

#Differential expression accross pseudotime

```{r ,message=FALSE, warning=FALSE}

Normalized_data <- M3DropCleanData(sce,
                      labels = rownames(sce),
                      is.counts=TRUE, min_detected_genes=2000)
DE_genes <- M3DropDifferentialExpression(Normalized_data$data,
  mt_method="fdr", mt_threshold=0.01)

d <- sce[which(rownames(sce) %in% DE_genes$Gene), ]
d <- d[!duplicated(rownames(d)), ]
colnames(d) <- 1:ncol(d)
geneNames <- rownames(d)
rownames(d) <- 1:nrow(d)
pd <- data.frame(timepoint = cellLabels)
pd <- new("AnnotatedDataFrame", data=pd)
fd <- data.frame(gene_short_name = geneNames)
fd <- new("AnnotatedDataFrame", data=fd)

dCellData <- newCellDataSet(d, phenoData = pd, featureData = fd, expressionFamily = tobit())
dCellData <- setOrderingFilter(dCellData, which(geneNames %in% DE_genes))
dCellData <- estimateSizeFactors(dCellData)
dCellDataSet <- reduceDimension(dCellData, pseudo_expr = 1)
dCellDataSet <- orderCells(dCellDataSet, reverse = FALSE)

diff_test_res <- differentialGeneTest(dCellDataSet,
                                      fullModelFormulaStr = "~sm.ns(Pseudotime)")

ensembl_to_symbol <- function(dataframe, ensembl_column){
  
  dataframe_tmp <- dataframe %>% 
    dplyr::select(ensembl_column)
  data <- unlist(dataframe_tmp)
  data <- as.vector(data)
  annots <-  AnnotationDbi::select(org.Hs.eg.db, keys=data,
                                   columns=c("SYMBOL","GENENAME"), keytype = "ENSEMBL")

  result <- merge(dataframe, annots, by.x=ensembl_column, by.y="ENSEMBL")
  return(result)
  }

diff_test_res <- ensembl_to_symbol(diff_test_res, "gene_short_name")

write.csv(diff_test_res, "pseaudotime_diff_exprs_hcc.csv")
```


```{r, include=FALSE}
pseudotime_monocle <-
    data.frame(
        Timepoint = phenoData(dCellDataSet)$timepoint,
        pseudotime = phenoData(dCellDataSet)$Pseudotime,
        State = phenoData(dCellDataSet)$State
    )
rownames(pseudotime_monocle) <- 1:ncol(d)
pseudotime_order_monocle <-
    rownames(pseudotime_monocle[order(pseudotime_monocle$pseudotime), ])
```


# Plot the cells ordered by pseudotime

```{r, echo=FALSE, message=FALSE, warning=FALSE}
sce.pass_hcc$pseudotime_monocle <- pseudotime_monocle$pseudotime
postscript("Figures.dir/Pseudotime_monocle_HCC.eps")
ggplot(as.data.frame(colData(sce.pass_hcc)), 
       aes(x = pseudotime_monocle, 
           y = Condition, colour = Condition)) +
    geom_quasirandom(groupOnX = FALSE) +
    scale_color_tableau() + theme_classic() +
    xlab("monocle pseudotime") + ylab("Timepoint") +
    ggtitle("Cells ordered by monocle pseudotime")
dev.off()
```

# DE accross pseudotime

```{r}
#postscript("Figures.dir/Pseudotime_heatmap.eps")
tiff("Figures.dir/Pseudotime_heatmap.tiff")
plot_pseudotime_heatmap(dCellDataSet,
                num_clusters = 4,
                cores = 2,
                show_rownames = F)
dev.off()
```